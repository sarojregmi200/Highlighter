{"version":3,"sources":["../../src/components/index.ts"],"sourcesContent":["import { createError } from '../errors.js'\nimport {\n  create as avlCreate,\n  find as avlFind,\n  greaterThan as avlGreaterThan,\n  insert as avlInsert,\n  lessThan as avlLessThan,\n  Node as AVLNode,\n  rangeSearch as avlRangeSearch,\n  removeDocument as avlRemoveDocument,\n} from '../trees/avl.js'\nimport {\n  create as radixCreate,\n  find as radixFind,\n  insert as radixInsert,\n  Node as RadixNode,\n  removeDocumentByWord as radixRemoveDocument,\n} from '../trees/radix.js'\nimport {\n  ArraySearchableType,\n  BM25Params,\n  ComparisonOperator,\n  IIndex,\n  OpaqueDocumentStore,\n  OpaqueIndex,\n  Orama,\n  ScalarSearchableType,\n  Schema,\n  SearchableType,\n  SearchableValue,\n  SearchContext,\n  Tokenizer,\n  TokenScore,\n} from '../types.js'\nimport { intersect } from '../utils.js'\nimport { BM25 } from './algorithms.js'\nimport { getInnerType, isArrayType } from './defaults.js'\nimport {\n  DocumentID,\n  getInternalDocumentId,\n  InternalDocumentID,\n  InternalDocumentIDStore,\n} from './internal-document-id-store.js'\n\nexport type FrequencyMap = {\n  [property: string]: {\n    [documentID: InternalDocumentID]:\n      | {\n          [token: string]: number\n        }\n      | undefined\n  }\n}\n\nexport type BooleanIndex = {\n  true: InternalDocumentID[]\n  false: InternalDocumentID[]\n}\n\nexport interface Index extends OpaqueIndex {\n  sharedInternalDocumentStore: InternalDocumentIDStore\n  indexes: Record<string, RadixNode | AVLNode<number, InternalDocumentID[]> | BooleanIndex>\n  searchableProperties: string[]\n  searchablePropertiesWithTypes: Record<string, SearchableType>\n  frequencies: FrequencyMap\n  tokenOccurrences: Record<string, Record<string, number>>\n  avgFieldLength: Record<string, number>\n  fieldLengths: Record<string, Record<InternalDocumentID, number | undefined>>\n}\n\nexport type DefaultIndex = IIndex<Index>\n\nexport async function insertDocumentScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  tokens: string[],\n  docsCount: number,\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  index.avgFieldLength[prop] = ((index.avgFieldLength[prop] ?? 0) * (docsCount - 1) + tokens.length) / docsCount\n  index.fieldLengths[prop][internalId] = tokens.length\n  index.frequencies[prop][internalId] = {}\n}\n\nexport async function insertTokenScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  tokens: string[],\n  token: string,\n): Promise<void> {\n  let tokenFrequency = 0\n\n  for (const t of tokens) {\n    if (t === token) {\n      tokenFrequency++\n    }\n  }\n\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n  const tf = tokenFrequency / tokens.length\n\n  index.frequencies[prop][internalId]![token] = tf\n\n  if (!(token in index.tokenOccurrences[prop])) {\n    index.tokenOccurrences[prop][token] = 0\n  }\n\n  // increase a token counter that may not yet exist\n  index.tokenOccurrences[prop][token] = (index.tokenOccurrences[prop][token] ?? 0) + 1\n}\n\nexport async function removeDocumentScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  docsCount: number,\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  index.avgFieldLength[prop] =\n    (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][internalId]!) / (docsCount - 1)\n  index.fieldLengths[prop][internalId] = undefined\n  index.frequencies[prop][internalId] = undefined\n}\n\nexport async function removeTokenScoreParameters(index: Index, prop: string, token: string): Promise<void> {\n  index.tokenOccurrences[prop][token]--\n}\n\nexport async function calculateResultScores<I extends OpaqueIndex, D extends OpaqueDocumentStore, AggValue>(\n  context: SearchContext<I, D, AggValue>,\n  index: Index,\n  prop: string,\n  term: string,\n  ids: DocumentID[],\n): Promise<TokenScore[]> {\n  const documentIDs = Array.from(ids)\n\n  // Exact fields for TF-IDF\n  const avgFieldLength = index.avgFieldLength[prop]\n  const fieldLengths = index.fieldLengths[prop]\n  const oramaOccurrences = index.tokenOccurrences[prop]\n  const oramaFrequencies = index.frequencies[prop]\n\n  // oramaOccurrences[term] can be undefined, 0, string, or { [k: string]: number }\n  const termOccurrences = typeof oramaOccurrences[term] === 'number' ? oramaOccurrences[term] ?? 0 : 0\n\n  const scoreList: TokenScore[] = []\n\n  // Calculate TF-IDF value for each term, in each document, for each index.\n  const documentIDsLength = documentIDs.length\n  for (let k = 0; k < documentIDsLength; k++) {\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, documentIDs[k])\n    const tf = oramaFrequencies?.[internalId]?.[term] ?? 0\n\n    const bm25 = BM25(\n      tf,\n      termOccurrences,\n      context.docsCount,\n      fieldLengths[internalId]!,\n      avgFieldLength,\n      context.params.relevance! as Required<BM25Params>,\n    )\n\n    scoreList.push([internalId, bm25])\n  }\n  return scoreList\n}\n\nexport async function create(\n  orama: Orama<{ Index: DefaultIndex }>,\n  sharedInternalDocumentStore: InternalDocumentIDStore,\n  schema: Schema,\n  index?: Index,\n  prefix = '',\n): Promise<Index> {\n  if (!index) {\n    index = {\n      sharedInternalDocumentStore,\n      indexes: {},\n      searchableProperties: [],\n      searchablePropertiesWithTypes: {},\n      frequencies: {},\n      tokenOccurrences: {},\n      avgFieldLength: {},\n      fieldLengths: {},\n    }\n  }\n\n  for (const [prop, type] of Object.entries(schema)) {\n    const typeActualType = typeof type\n    const path = `${prefix}${prefix ? '.' : ''}${prop}`\n\n    if (typeActualType === 'object' && !Array.isArray(type)) {\n      // Nested\n      create(orama, sharedInternalDocumentStore, type as Schema, index, path)\n      continue\n    }\n\n    switch (type) {\n      case 'boolean':\n      case 'boolean[]':\n        index.indexes[path] = { true: [], false: [] }\n        break\n      case 'number':\n      case 'number[]':\n        index.indexes[path] = avlCreate<number, InternalDocumentID[]>(0, [])\n        break\n      case 'string':\n      case 'string[]':\n        index.indexes[path] = radixCreate()\n        index.avgFieldLength[path] = 0\n        index.frequencies[path] = {}\n        index.tokenOccurrences[path] = {}\n        index.fieldLengths[path] = {}\n        break\n      default:\n        throw createError('INVALID_SCHEMA_TYPE', Array.isArray(type) ? 'array' : (type as unknown as string), path)\n    }\n\n    index.searchableProperties.push(path)\n    index.searchablePropertiesWithTypes[path] = type\n  }\n\n  return index\n}\n\nasync function insertScalar(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: ScalarSearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  switch (schemaType) {\n    case 'boolean': {\n      const booleanIndex = index.indexes[prop] as BooleanIndex\n      booleanIndex[value ? 'true' : 'false'].push(internalId)\n      break\n    }\n    case 'number':\n      avlInsert(index.indexes[prop] as AVLNode<number, number[]>, value as number, [internalId])\n      break\n    case 'string': {\n      const tokens = await tokenizer.tokenize(value as string, language, prop)\n      await implementation.insertDocumentScoreParameters(index, prop, internalId, tokens, docsCount)\n\n      for (const token of tokens) {\n        await implementation.insertTokenScoreParameters(index, prop, internalId, tokens, token)\n\n        radixInsert(index.indexes[prop] as RadixNode, token, internalId)\n      }\n\n      break\n    }\n  }\n}\n\nexport async function insert(\n  implementation: DefaultIndex,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<void> {\n  if (!isArrayType(schemaType)) {\n    return insertScalar(\n      implementation,\n      index,\n      prop,\n      id,\n      value,\n      schemaType as ScalarSearchableType,\n      language,\n      tokenizer,\n      docsCount,\n    )\n  }\n\n  const innerSchemaType = getInnerType(schemaType as ArraySearchableType)\n\n  const elements = value as Array<string | number | boolean>\n  const elementsLength = elements.length\n  for (let i = 0; i < elementsLength; i++) {\n    await insertScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount)\n  }\n}\n\nasync function removeScalar(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: ScalarSearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<boolean> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  switch (schemaType) {\n    case 'number': {\n      avlRemoveDocument(index.indexes[prop] as AVLNode<number, InternalDocumentID[]>, internalId, value)\n      return true\n    }\n    case 'boolean': {\n      const booleanKey = value ? 'true' : 'false'\n      const position = (index.indexes[prop] as BooleanIndex)[booleanKey].indexOf(internalId)\n\n      ;(index.indexes[prop] as BooleanIndex)[value ? 'true' : 'false'].splice(position, 1)\n      return true\n    }\n    case 'string': {\n      const tokens = await tokenizer.tokenize(value as string, language, prop)\n\n      await implementation.removeDocumentScoreParameters(index, prop, id, docsCount)\n\n      for (const token of tokens) {\n        await implementation.removeTokenScoreParameters(index, prop, token)\n        radixRemoveDocument(index.indexes[prop] as RadixNode, token, internalId)\n      }\n\n      return true\n    }\n  }\n}\n\nexport async function remove(\n  implementation: DefaultIndex,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<boolean> {\n  if (!isArrayType(schemaType)) {\n    return removeScalar(\n      implementation,\n      index,\n      prop,\n      id,\n      value,\n      schemaType as ScalarSearchableType,\n      language,\n      tokenizer,\n      docsCount,\n    )\n  }\n\n  const innerSchemaType = getInnerType(schemaType as ArraySearchableType)\n\n  const elements = value as Array<string | number | boolean>\n  const elementsLength = elements.length\n  for (let i = 0; i < elementsLength; i++) {\n    await removeScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount)\n  }\n\n  return true\n}\n\nexport async function search<D extends OpaqueDocumentStore, AggValue>(\n  context: SearchContext<Index, D, AggValue>,\n  index: Index,\n  prop: string,\n  term: string,\n): Promise<TokenScore[]> {\n  if (!(prop in index.tokenOccurrences)) {\n    return []\n  }\n\n  // Performa the search\n  const rootNode = index.indexes[prop] as RadixNode\n  const { exact, tolerance } = context.params\n  const searchResult = radixFind(rootNode, { term, exact, tolerance })\n  const ids = new Set<InternalDocumentID>()\n\n  for (const key in searchResult) {\n    for (const id of searchResult[key]) {\n      ids.add(id)\n    }\n  }\n\n  return context.index.calculateResultScores(context, index, prop, term, Array.from(ids))\n}\n\nexport async function searchByWhereClause<I extends OpaqueIndex, D extends OpaqueDocumentStore, AggValue>(\n  context: SearchContext<I, D, AggValue>,\n  index: Index,\n  filters: Record<string, boolean | ComparisonOperator>,\n): Promise<number[]> {\n  const filterKeys = Object.keys(filters)\n\n  const filtersMap: Record<string, InternalDocumentID[]> = filterKeys.reduce(\n    (acc, key) => ({\n      [key]: [],\n      ...acc,\n    }),\n    {},\n  )\n\n  for (const param of filterKeys) {\n    const operation = filters[param]\n\n    if (typeof operation === 'boolean') {\n      const idx = index.indexes[param] as BooleanIndex\n\n      if (typeof idx === 'undefined') {\n        throw createError('UNKNOWN_FILTER_PROPERTY', param)\n      }\n\n      const filteredIDs = idx[operation.toString() as keyof BooleanIndex]\n      filtersMap[param].push(...filteredIDs)\n      continue\n    }\n\n    if (typeof operation === 'string' || Array.isArray(operation)) {\n      const idx = index.indexes[param] as RadixNode\n\n      if (typeof idx === 'undefined') {\n        throw createError('UNKNOWN_FILTER_PROPERTY', param)\n      }\n\n      for (const raw of [operation].flat()) {\n        const term = await context.tokenizer.tokenize(raw, context.language, param)\n        const filteredIDsResults = radixFind(idx, { term: term[0], exact: true })\n        filtersMap[param].push(...Object.values(filteredIDsResults).flat())\n      }\n\n      continue\n    }\n\n    const operationKeys = Object.keys(operation)\n\n    if (operationKeys.length > 1) {\n      throw createError('INVALID_FILTER_OPERATION', operationKeys.length)\n    }\n\n    const operationOpt = operationKeys[0] as keyof ComparisonOperator\n    const operationValue = operation[operationOpt]\n\n    const AVLNode = index.indexes[param] as AVLNode<number, InternalDocumentID[]>\n\n    if (typeof AVLNode === 'undefined') {\n      throw createError('UNKNOWN_FILTER_PROPERTY', param)\n    }\n\n    switch (operationOpt) {\n      case 'gt': {\n        const filteredIDs = avlGreaterThan(AVLNode, operationValue, false)\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'gte': {\n        const filteredIDs = avlGreaterThan(AVLNode, operationValue, true)\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'lt': {\n        const filteredIDs = avlLessThan(AVLNode, operationValue, false)\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'lte': {\n        const filteredIDs = avlLessThan(AVLNode, operationValue, true)\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'eq': {\n        const filteredIDs = avlFind(AVLNode, operationValue) ?? []\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'between': {\n        const [min, max] = operationValue as number[]\n        const filteredIDs = avlRangeSearch(AVLNode, min, max)\n        filtersMap[param].push(...filteredIDs)\n      }\n    }\n  }\n\n  // AND operation: calculate the intersection between all the IDs in filterMap\n  const result = intersect(Object.values(filtersMap))\n\n  return result\n}\n\nexport async function getSearchableProperties(index: Index): Promise<string[]> {\n  return index.searchableProperties\n}\n\nexport async function getSearchablePropertiesWithTypes(index: Index): Promise<Record<string, SearchableType>> {\n  return index.searchablePropertiesWithTypes\n}\n\nfunction loadNode(node: RadixNode): RadixNode {\n  const convertedNode = radixCreate(node.end, node.subWord, node.key)\n\n  convertedNode.docs = node.docs\n  convertedNode.word = node.word\n\n  for (const childrenKey of Object.keys(node.children)) {\n    convertedNode.children[childrenKey] = loadNode(node.children[childrenKey])\n  }\n\n  return convertedNode\n}\n\nexport async function load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): Promise<Index> {\n  const {\n    indexes: rawIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  } = raw as Index\n\n  const indexes: Index['indexes'] = {}\n\n  for (const prop of Object.keys(rawIndexes)) {\n    const value = rawIndexes[prop]\n\n    if (!('word' in value)) {\n      indexes[prop] = value\n\n      continue\n    }\n\n    indexes[prop] = loadNode(value)\n  }\n\n  return {\n    sharedInternalDocumentStore,\n    indexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  }\n}\n\nexport async function save<R = unknown>(index: Index): Promise<R> {\n  const {\n    indexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  } = index\n\n  return {\n    indexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  } as R\n}\n\nexport async function createIndex(): Promise<DefaultIndex> {\n  return {\n    create,\n    insert,\n    remove,\n    insertDocumentScoreParameters,\n    insertTokenScoreParameters,\n    removeDocumentScoreParameters,\n    removeTokenScoreParameters,\n    calculateResultScores,\n    search,\n    searchByWhereClause,\n    getSearchableProperties,\n    getSearchablePropertiesWithTypes,\n    load,\n    save,\n  }\n}\n"],"names":["createError","create","avlCreate","find","avlFind","greaterThan","avlGreaterThan","insert","avlInsert","lessThan","avlLessThan","rangeSearch","avlRangeSearch","removeDocument","avlRemoveDocument","radixCreate","radixFind","radixInsert","removeDocumentByWord","radixRemoveDocument","intersect","BM25","getInnerType","isArrayType","getInternalDocumentId","insertDocumentScoreParameters","index","prop","id","tokens","docsCount","internalId","sharedInternalDocumentStore","avgFieldLength","length","fieldLengths","frequencies","insertTokenScoreParameters","token","tokenFrequency","t","tf","tokenOccurrences","removeDocumentScoreParameters","undefined","removeTokenScoreParameters","calculateResultScores","context","term","ids","documentIDs","Array","from","oramaOccurrences","oramaFrequencies","termOccurrences","scoreList","documentIDsLength","k","bm25","params","relevance","push","orama","schema","prefix","indexes","searchableProperties","searchablePropertiesWithTypes","type","Object","entries","typeActualType","path","isArray","true","false","insertScalar","implementation","value","schemaType","language","tokenizer","booleanIndex","tokenize","innerSchemaType","elements","elementsLength","i","removeScalar","booleanKey","position","indexOf","splice","remove","search","rootNode","exact","tolerance","searchResult","Set","key","add","searchByWhereClause","filters","filterKeys","keys","filtersMap","reduce","acc","param","operation","idx","filteredIDs","toString","raw","flat","filteredIDsResults","values","operationKeys","operationOpt","operationValue","AVLNode","min","max","result","getSearchableProperties","getSearchablePropertiesWithTypes","loadNode","node","convertedNode","end","subWord","docs","word","childrenKey","children","load","rawIndexes","save","createIndex"],"mappings":"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"}