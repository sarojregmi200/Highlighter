{"version":3,"sources":["../../src/trees/radix.ts"],"sourcesContent":["import { syncBoundedLevenshtein } from '../components/levenshtein.js'\nimport { InternalDocumentID } from '../components/internal-document-id-store.js'\nimport { getOwnProperty } from '../utils.js'\n\nexport class Node {\n  constructor(key: string, subWord: string, end: boolean) {\n    this.key = key\n    this.subWord = subWord\n    this.end = end\n  }\n\n  public key: string\n  public subWord: string\n  public children: Record<string, Node> = {}\n  public docs: InternalDocumentID[] = []\n  public end: boolean\n  public word = ''\n\n  public toJSON(): object {\n    return {\n      word: this.word,\n      subWord: this.subWord,\n      children: this.children,\n      docs: this.docs,\n      end: this.end,\n    }\n  }\n}\n\ntype FindParams = {\n  term: string\n  exact?: boolean\n  tolerance?: number\n}\n\ntype FindResult = Record<string, InternalDocumentID[]>\n\nfunction updateParent(node: Node, parent: Node): void {\n  node.word = parent.word + node.subWord\n}\n\nfunction addDocument(node: Node, docID: InternalDocumentID): void {\n  node.docs.push(docID)\n}\n\nfunction removeDocument(node: Node, docID: InternalDocumentID): boolean {\n  const index = node.docs.indexOf(docID)\n\n  /* c8 ignore next 3 */\n  if (index === -1) {\n    return false\n  }\n\n  node.docs.splice(index, 1)\n\n  return true\n}\n\nfunction findAllWords(node: Node, output: FindResult, term: string, exact?: boolean, tolerance?: number) {\n  if (node.end) {\n    const { word, docs: docIDs } = node\n\n    if (exact && word !== term) {\n      return {}\n    }\n\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (!getOwnProperty(output, word)) {\n      if (tolerance) {\n        // computing the absolute difference of letters between the term and the word\n        const difference = Math.abs(term.length - word.length)\n\n        // if the tolerance is set, check whether the edit distance is within tolerance.\n        // In that case, we don't need to add the word to the output\n        if (difference <= tolerance && syncBoundedLevenshtein(term, word, tolerance).isBounded) {\n          output[word] = []\n        }\n      } else {\n        // prevent default tolerance not set\n        output[word] = []\n      }\n    }\n\n    // check if _output[word] exists and then add the doc to it\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (getOwnProperty(output, word) && docIDs.length) {\n      const docs = new Set(output[word])\n\n      const docIDsLength = docIDs.length\n      for (let i = 0; i < docIDsLength; i++) {\n        docs.add(docIDs[i])\n      }\n      output[word] = Array.from(docs)\n    }\n  }\n\n  // recursively search the children\n  for (const character of Object.keys(node.children)) {\n    findAllWords(node.children[character], output, term, exact, tolerance)\n  }\n  return output\n}\n\nfunction getCommonPrefix(a: string, b: string) {\n  let commonPrefix = ''\n  const len = Math.min(a.length, b.length)\n  for (let i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      return commonPrefix\n    }\n    commonPrefix += a[i]\n  }\n  return commonPrefix\n}\n\nexport function create(end = false, subWord = '', key = ''): Node {\n  return new Node(key, subWord, end)\n}\n\nexport function insert(root: Node, word: string, docId: InternalDocumentID) {\n  for (let i = 0; i < word.length; i++) {\n    const currentCharacter = word[i]\n    const wordAtIndex = word.substring(i)\n    const rootChildCurrentChar = root.children[currentCharacter]\n\n    if (rootChildCurrentChar) {\n      const edgeLabel = rootChildCurrentChar.subWord\n      const edgeLabelLength = edgeLabel.length\n\n      const commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex)\n      const commonPrefixLength = commonPrefix.length\n\n      // the wordAtIndex matches exactly with an existing child node\n      if (edgeLabel === wordAtIndex) {\n        addDocument(rootChildCurrentChar, docId)\n        rootChildCurrentChar.end = true\n        return\n      }\n\n      const edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength]\n      // the wordAtIndex is completely contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {\n        const newNode = create(true, wordAtIndex, currentCharacter) // Create a new node with end set to true\n        newNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar\n\n        const newNodeChild = newNode.children[edgeLabelAtCommonPrefix]\n        newNodeChild.subWord = edgeLabel.substring(commonPrefixLength)\n        newNodeChild.key = edgeLabelAtCommonPrefix\n\n        root.children[currentCharacter] = newNode\n\n        updateParent(newNode, root)\n        updateParent(newNodeChild, newNode)\n        addDocument(newNode, docId)\n        return\n      }\n\n      // the wordAtIndex is partially contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {\n        const inbetweenNode = create(false, commonPrefix, currentCharacter)\n        inbetweenNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar\n        root.children[currentCharacter] = inbetweenNode\n\n        const inbetweenNodeChild = inbetweenNode.children[edgeLabelAtCommonPrefix]\n        inbetweenNodeChild.subWord = edgeLabel.substring(commonPrefixLength)\n        inbetweenNodeChild.key = edgeLabelAtCommonPrefix\n\n        const wordAtCommonPrefix = wordAtIndex[commonPrefixLength]\n        const newNode = create(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix)\n        addDocument(newNode, docId)\n\n        inbetweenNode.children[wordAtCommonPrefix] = newNode\n\n        updateParent(inbetweenNode, root)\n        updateParent(newNode, inbetweenNode)\n        updateParent(inbetweenNodeChild, inbetweenNode)\n        return\n      }\n\n      // skip to the next divergent character\n      i += edgeLabelLength - 1\n      // navigate in the child node\n      root = rootChildCurrentChar\n    } else {\n      // if the node for the current character doesn't exist create new node\n      const newNode = create(true, wordAtIndex, currentCharacter)\n      addDocument(newNode, docId)\n\n      root.children[currentCharacter] = newNode\n      updateParent(newNode, root)\n      return\n    }\n  }\n}\n\nexport function find(root: Node, { term, exact, tolerance }: FindParams): FindResult {\n  // find the closest node to the term\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    if (character in root.children) {\n      const rootChildCurrentChar = root.children[character]\n      const edgeLabel = rootChildCurrentChar.subWord\n      const termSubstring = term.substring(i)\n\n      // find the common prefix between two words ex: prime and primate = prim\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring)\n      const commonPrefixLength = commonPrefix.length\n      // if the common prefix length is equal to edgeLabel length (the node subword) it means they are a match\n      // if the common prefix is equal to the term means it is contained in the node\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        // if tolerance is set we take the current node as the closest\n        if (tolerance) break\n        return {}\n      }\n\n      // skip the subword length and check the next divergent character\n      i += rootChildCurrentChar.subWord.length - 1\n      // navigate into the child node\n      root = rootChildCurrentChar\n    } else {\n      return {}\n    }\n  }\n\n  const output: FindResult = {}\n  // found the closest node we recursively search through children\n  findAllWords(root, output, term, exact, tolerance)\n\n  return output\n}\n\nexport function contains(root: Node, term: string): boolean {\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n\n    if (character in root.children) {\n      const rootChildrenChar = root.children[character]\n      const edgeLabel = rootChildrenChar.subWord\n      const termSubstring = term.substring(i)\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring)\n      const commonPrefixLength = commonPrefix.length\n\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        return false\n      }\n      i += rootChildrenChar.subWord.length - 1\n      root = rootChildrenChar\n    } else {\n      return false\n    }\n  }\n  return true\n}\n\nexport function removeWord(root: Node, term: string): boolean {\n  if (!term) {\n    return false\n  }\n\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    const parent = root\n    if (character in root.children) {\n      i += root.children[character].subWord.length - 1\n      root = root.children[character]\n\n      if (Object.keys(root.children).length === 0) {\n        delete parent.children[root.key]\n        return true\n      }\n    } else {\n      return false\n    }\n  }\n\n  return false\n}\n\nexport function removeDocumentByWord(root: Node, term: string, docID: InternalDocumentID, exact = true): boolean {\n  if (!term) {\n    return true\n  }\n\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    if (character in root.children) {\n      const rootChildCurrentChar = root.children[character]\n      i += rootChildCurrentChar.subWord.length - 1\n      root = rootChildCurrentChar\n\n      if (exact && root.word !== term) {\n        // Do nothing if the exact condition is not met.\n      } else {\n        removeDocument(root, docID)\n      }\n    } else {\n      return false\n    }\n  }\n  return true\n}\n"],"names":["syncBoundedLevenshtein","getOwnProperty","Node","constructor","key","subWord","end","children","docs","word","toJSON","updateParent","node","parent","addDocument","docID","push","removeDocument","index","indexOf","splice","findAllWords","output","term","exact","tolerance","docIDs","difference","Math","abs","length","isBounded","Set","docIDsLength","i","add","Array","from","character","Object","keys","getCommonPrefix","a","b","commonPrefix","len","min","create","insert","root","docId","currentCharacter","wordAtIndex","substring","rootChildCurrentChar","edgeLabel","edgeLabelLength","commonPrefixLength","edgeLabelAtCommonPrefix","newNode","newNodeChild","inbetweenNode","inbetweenNodeChild","wordAtCommonPrefix","find","termSubstring","contains","rootChildrenChar","removeWord","removeDocumentByWord"],"mappings":"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"}